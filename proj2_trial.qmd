---
title: "Project 2 test file"
author: "Lamia Benyamine"
format: html
editor: visual
---

```{r}
#libraries needed

library(jsonlite)
library(dplyr)
library(httr)
library(tidyverse)
library(lubridate)
library(ggplot2)
library(GGally)

```

API function w endpoints

```{r}
#https://api.energidataservice.dk/dataset/DeclarationProduction?
#https://api.energidataservice.dk/dataset/StorageUtilization?limit=5
#https://api.energidataservice.dk/dataset/Forecasts_Hour?limit=5
energiAPI("Forecasts_Hour",startD = "2024-06-01", priceArea = "DK1")
```

```{r}
#Forecasts_Hour

forecastPower <- function(startDate, forecastType = "all"){
  baseURL <- "https://api.energidataservice.dk/dataset/"
  if(forecastType == "all") {
    ep1 <- "Forecasts_Hour?columns=TimestampUTC,PriceArea,ForecastType,ForecastCurrent&start="
    urlID <- paste(baseURL, ep1, startDate, sep = "")
  }
  else {
    ep1 <- "Forecasts_Hour?columns=TimestampUTC,PriceArea,ForecastType,ForecastCurrent&start="
    ep2 <- "&filter={\"ForecastType\":[\""
    ep3 <- "\"]}"
    urlID <- paste(baseURL, ep1, startDate, ep2, forecastType, ep3, sep = "")
  }
  
  parsed <- fromJSON(urlID)
  data_tb <- as_tibble(parsed$records) |>
    mutate(hour = hour(ymd_hms(TimestampUTC)), TimestampUTC = as_date(ymd_hms(TimestampUTC))) |>
    select(TimestampUTC, hour, everything())|>
    group_by(TimestampUTC, hour, PriceArea)
  return(data_tb)
}
#forecastPower("2024-06-24", "all")

#DeclarationProduction
productionPower <- function(sortDes, productionType, num){
  baseURL <- "https://api.energidataservice.dk/dataset/"
  
  if(productionType == "all") {
    ep1 <- "DeclarationProduction?start=2024-01-01&columns=HourUTC,PriceArea,ProductionType,DeliveryType,CO2PerkWh,SO2PerkWh,NOxPerkWh,COPerkWh&sort="
    ep2 <- "%20desc&limit="
    urlID <- paste(baseURL, ep1, sortDes, ep2, num, sep = "")
  }
  else {
    ep1 <- "DeclarationProduction?start=2024-01-01&columns=HourUTC,PriceArea,ProductionType,DeliveryType,CO2PerkWh,SO2PerkWh,NOxPerkWh,COPerkWh&filter={\"ProductionType\":[\""
    ep2 <- "\"]}&sort="
    ep3 <- "%20desc&limit="
    urlID <- paste(baseURL, ep1, productionType, ep2, sortDes, ep3, num, sep = "")
  }
  
  parsed <- fromJSON(urlID)
  data_tb <- as_tibble(parsed$records) |>
    mutate(dateUTC = as_date(ymd_hms(HourUTC)), hour = hour(ymd_hms(HourUTC))) |>
      select(dateUTC, hour, 2:6)|>
      group_by(dateUTC, hour, PriceArea)
  return(data_tb)
}
#productionPower(sortDes = "CO2PerkWh", productionType = "all", num = 100)


# Storage Utilization Endpoint function that allows the user to input start date and number of records. Gas Day is sorting ascending do the number of records selected is from the date the user selects. Only the total utilization columns are selected.
storageUsage <- function(startDate, num){
  baseURL <- "https://api.energidataservice.dk/dataset/"
  ep1 <- "StorageUtilization?sort=GasDay&start="
  ep2 <- "&limit="
  
  urlID <- paste(baseURL, ep1, startDate, ep2, num, sep = "")
  
  parsed <- fromJSON(urlID)
  data_tb <- as_tibble(parsed$records) |>
    mutate(GasDay = as_date(ymd_hms(GasDay))) |>
    select(GasDay, contains("Total"))
  return(data_tb)
}
#storageUsage(startDate = "2024-05-01", num = 50)
```

API wrapper function

```{r}
energiAPI <- function(data,...){
  if(data == "forecastPower"){
    output <- forecastPower(...)
  }
  else if(data == "productionPower"){
    output <- productionPower(...)
  }
  else if(data == "storageUsage"){
    output <- storageUsage(...)
  }
  else {
    print("ERROR: Please input a valid data argument: forecastPower, productionPower, storageUsage")
    return(NA_real_)
    stop()
  }
  return(output)
}

data_tb <- energiAPI("productionPower", sortDes = "HourUTC", productionType = "all", num = 0)

energiAPI("forecastPower", startDate = "2024-06-24", forecastType = "solar") 

energiAPI("storageUsage", startDate = "2024-06-24", num = 10000)
```

summary visuals

```{r}

##NEED TO update price area labels to desc

#one-way contingency
data_tb |>
  group_by(ProductionType) |>
  summarize(count = n())

#two-way contingency
data_tb |>
  group_by(ProductionType, PriceArea) |>
 # summarize(count = n()) |>
  summarize(mean_CO2 = mean(CO2PerkWh)) |>
  pivot_wider(names_from = PriceArea, values_from = mean_CO2)

#center
sum <- data_tb |>
  group_by(ProductionType) |>
  summarize(mean_co2 = mean(CO2PerkWh), mean_SO2 = mean(SO2PerkWh)) 
sum
       
 summarize(across(where(is.numeric), list("mean"=mean, "median"=median), .names = "{.fn}_(.col}"))
 
 

```

```{r}
prodInfo <- energiAPI(data = "productionPower", sortDes = "HourUTC", productionType = "all", num = 30000) |>
        mutate(prodType = as.factor(ProductionType))

prod_tb <- prodInfo |>
          group_by(prodType, PriceArea) |>
          summarize(mean_co2 = mean(CO2PerkWh))
        prod_tb
     
        prod_tb <- prodInfo |>
          group_by(prodType, PriceArea) |>
          summarize(mean_co2 = mean(CO2PerkWh), .groups = 'drop')
        prod_tb
        
  g <- ggplot(prodInfo |> filter(dateUTC >= '2024-01-01'), stat = "mean", aes(x= prodType))  
   g + geom_bar()
   
   
    g <- ggplot(prod_tb |> filter(dateUTC >= '2024-01-01'), stat = "mean", aes(x= prodType))  
   g + geom_bar()
  g
  
  ggplot(aes(x = prod_tb, y = CO2PerkWh, fill=PriceArea), data = prodInfo) +
    stat_summary(fun=mean, geom="bar", position = "stack") +
    xlab("Production Type")
  
  #facet by product type mean co2
  g<- ggplot(aes(x = prodType, y = mean_co2), data = prod_tb)
  g + geom_col() +facet_wrap(~ PriceArea) + theme_light() + ylab("mean CO2 per kWh") + xlab("Production Type") + ggtitle("Mean CO2 values by Production Type, Faceted by Price Area") + theme(axis.text.x=element_text(angle=60, hjust=1)) 


  #correlation bw co & so2
  ggpairs(prodInfo, columns = 6:7, ggplot2::aes(color=PriceArea)) + ggtitle("Correlation between CO2 per kWH and SO2 per kwh emissions by Price Area")
  

```

```{r}
forcInfo <- energiAPI(data = "forecastPower", forecastType = "all", startDate = '2024-01-02') |>
      mutate(forcType = as.factor(ForecastType))

forc_tb <- forcInfo |>
          group_by(forcType, TimestampUTC) |>
          summarize(mean_forecast = round(mean(ForecastCurrent)), median_forecast = median(ForecastCurrent), .groups = 'drop')

#if(mean power by date)
p <- ggplot(forc_tb, aes(x=TimestampUTC, y = mean_forecast)) + geom_line(color="steelblue") +  geom_point(size = 0.5, color = "steelblue") + scale_x_date(date_labels = "%b-%Y") + ylab("Mean forecast MWh") + ggtitle("Time series of Mean Power Forecast") + theme_light() +facet_wrap(~ forcType)
p

#mean forecast by type and price area
g<- ggplot(data = forcInfo |> mutate(meanForecast = round(mean(ForecastCurrent))) |> group_by(forcType, PriceArea), aes(x = forcType, y = meanForecast, fill = PriceArea))
  g + geom_col() + ggtitle("Mean Power Forecast by Forecast Type and Price Area") + ylab("Mean forecast MWh") + xlab("Forecast Type") + theme_light()
```


